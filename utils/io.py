import json, os, shutil
from typing import Dict, Any, Union
from pathlib import Path

import numpy as np
from PIL import Image

import torch

# TODO: this was heavily generated by ChatGPT, so might have to acknnowledge that

FrameMap = Dict[int, Dict[str, Dict[str, Any]]]

def _to_numpy_mask(x: Any) -> np.ndarray:
    """Coerce various mask types -> numpy (H,W)."""
    if isinstance(x, torch.Tensor):
        x = x.detach().cpu().numpy()
    if isinstance(x, Image.Image):
        # Convert to L then to array
        return np.array(x.convert("L"))
    x = np.asarray(x)
    # If 3-channel, convert to grayscale (simple mean)
    if x.ndim == 3:
        x = x.mean(axis=-1)
    return x

def _to_uint8_binary(mask: np.ndarray, threshold: float = 0.5) -> np.ndarray:
    """Return uint8 0/255 mask. Accepts float [0,1] or any numeric type."""
    m = mask
    if m.dtype == bool:
        m = m.astype(np.uint8) * 255
    else:
        m = m.astype(np.float32)
        # If values look like 0..255 already, just threshold at 128; else at threshold*1.0
        if m.max() > 1.5:
            m = (m >= 128).astype(np.uint8) * 255
        else:
            m = (m >= threshold).astype(np.uint8) * 255
    return m

def _save_mask_file(
    mask_obj: Any,
    pid: str,
    frame_idx: int,
    masks_root: Path,
    zero_pad: int,
    copy_existing_masks: bool,
    threshold: float
) -> Path:
    """Save mask to PNG under masks_root/pid/000123.png, or copy/reference existing path."""
    pid_dir = masks_root / str(pid)
    pid_dir.mkdir(parents=True, exist_ok=True)
    fname = f"{frame_idx:0{zero_pad}d}.png"
    out_path = pid_dir / fname

    # Case 1: string path provided
    if isinstance(mask_obj, (str, Path)):
        src = Path(mask_obj)
        if copy_existing_masks:
            # Copy into our structure
            if src.resolve() != out_path.resolve():
                out_path.parent.mkdir(parents=True, exist_ok=True)
                shutil.copyfile(str(src), str(out_path))
            return out_path
        else:
            # Just reference source path
            return src

    # Case 2: array / PIL / tensor â†’ write PNG
    arr = _to_numpy_mask(mask_obj)
    arr = _to_uint8_binary(arr, threshold=threshold)
    Image.fromarray(arr, mode="L").save(out_path)
    return out_path

def _to_jsonable(x: Any) -> Any:
    """Recursively convert numpy types to plain Python for JSON."""
    if isinstance(x, np.ndarray):
        return x.tolist()
    if isinstance(x, dict):
        return {k: _to_jsonable(v) for k, v in x.items()}
    if isinstance(x, (np.generic,)):
        return x.item()
    if isinstance(x, Path):
        return str(x)
    return x

def save_frame_map_jsonl_with_masks(
    frame_map: FrameMap,
    out_file: Union[str, Path],
    masks_root: Union[str, Path],
    *,
    zero_pad: int = 5,
    mask_key_in: str = "phalp_mask",
    mask_key_out: str = "mask_file",
    copy_existing_masks: bool = False,
    threshold: float = 0.5,
) -> None:
    """
    Save {frame_idx -> {pid -> info}} to JSONL while writing masks to disk.

    - Writes masks to: masks_root/{pid}/{frame_id}.png
    - In JSON, replaces `mask_key_in` with `mask_key_out` path (relative to scene_root if possible).

    Args:
        frame_map: {int: {pid: { 'bbox','smpl_param','phalp_mask','phalp_j3ds','phalp_j2ds' }}}
        out_file: path to annotations.jsonl (typically under scene_root/)
        masks_root: directory where masks will be written (e.g., scene_root/"masks")
        zero_pad: zero-padding for frame_id strings (e.g., 000123)
        mask_key_in: key in your input dict holding the mask object/path
        mask_key_out: key written in JSON with a path string
        copy_existing_masks: if True, copy existing mask files into masks_root; else reference them
        threshold: threshold used when converting float masks to binary (0..1 scale)
    """
    out_file = Path(out_file)
    masks_root = Path(masks_root)
    out_file.parent.mkdir(parents=True, exist_ok=True)
    masks_root.mkdir(parents=True, exist_ok=True)

    # Try to store mask paths relative to the scene root (parent of annotations file)
    scene_root = out_file.parent

    with out_file.open("w", encoding="utf-8") as f:
        for frame_idx in sorted(frame_map.keys()):
            persons_in = frame_map[frame_idx]
            persons_out: Dict[str, Any] = {}
            for pid, info in persons_in.items():
                info = dict(info)  # shallow copy
                # Extract and save mask
                if mask_key_in not in info:
                    raise KeyError(f"Missing '{mask_key_in}' in frame {frame_idx}, pid {pid}")
                saved_path = _save_mask_file(
                    info[mask_key_in], pid, frame_idx, masks_root, zero_pad,
                    copy_existing_masks=copy_existing_masks, threshold=threshold
                )
                # Replace mask field with path (prefer path relative to scene_root if possible)
                try:
                    mask_rel = saved_path.relative_to(scene_root)
                    info[mask_key_out] = str(mask_rel).replace(os.sep, "/")
                except ValueError:
                    info[mask_key_out] = str(saved_path)

                # Remove original mask payload
                del info[mask_key_in]

                # Convert the remaining fields to JSON-safe types
                persons_out[p_id := pid] = _to_jsonable(info)

            record = {
                "frame_id": f"{frame_idx:0{zero_pad}d}",
                "frame_index": int(frame_idx),
                "persons": persons_out,
            }
            f.write(json.dumps(record, ensure_ascii=False) + "\n")


def load_frame_map_jsonl_restore(
    in_file: Union[str, Path],
    scene_root: Union[str, Path],
    *,
    mask_key_out: str = "mask_file",
    mask_key_in: str = "phalp_mask",
    to_numpy: bool = True
) -> FrameMap:
    """
    Load annotations JSONL and restore to the original {frame_idx -> {pid -> info}} format,
    including masks loaded back into memory.

    Args:
        in_file: path to annotations.jsonl
        scene_root: root directory (so mask_file paths can be resolved)
        mask_key_out: key stored in JSON (default "mask_file")
        mask_key_in: key restored in dict (default "phalp_mask")
        to_numpy: if True, masks are loaded as numpy arrays (H,W)
    """
    fm: FrameMap = {}
    in_file = Path(in_file)
    scene_root = Path(scene_root)

    with in_file.open("r", encoding="utf-8") as f:
        for line in f:
            rec = json.loads(line)
            idx = int(rec.get("frame_index", rec["frame_id"]))
            persons = {}
            for pid, info in rec["persons"].items():
                info = dict(info)  # shallow copy

                # Restore mask
                if mask_key_out in info:
                    mask_path = scene_root / info[mask_key_out]
                    if to_numpy:
                        mask = np.array(Image.open(mask_path).convert("L"))
                    else:
                        mask = Image.open(mask_path).convert("L")
                    info[mask_key_in] = mask
                    del info[mask_key_out]

                # Convert numeric lists back to numpy arrays where it makes sense
                for k in ("bbox", "phalp_j3ds", "phalp_j2ds"):
                    if k in info and isinstance(info[k], list):
                        info[k] = np.asarray(info[k], dtype=np.float32)

                if "smpl_param" in info and isinstance(info["smpl_param"], dict):
                    sp = info["smpl_param"]
                    for k, v in sp.items():
                        if isinstance(v, list):
                            sp[k] = np.asarray(v, dtype=np.float32)

                persons[int(pid)] = info
            fm[idx] = persons
    return fm
